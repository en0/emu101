# Using HACK assembly

SY | Name                            | Initial
===============================================
A  | Address Register                | 0x0000
D  | Data Register                   | 0x0000
PC | Program Counter                 | 0xfffc
SP | Stack Pointer                   | 0x01FF

START  | END    | Content           | Size
==============================================
0x0000 | 0x01FF | Stack             | 512
0x0200 | 0xEFFF | General Purpose   | 59.5k
0xF000 | 0xFFFF | PROG              | 4k

# Computation Instruction

1--ACCCC CCDDDJJJ
^ Denotes a c-instruction

Instruction Decoding
Part    | Description
==============================
A       | By-Reference Mode
CCCCCC  | Computation selector
DDD     | Destination Selector
JJJ     | Jump

Destination Selector
Code | Name       | Description
==================================================
 000 | None       | Disregard result
 001 | A          | Store into A
 010 | D          | Store into D
 100 | Memory[A]  | Store into Memory @ A

Jump Selector - Jump to address stored in A
Code | Name       | Description
==================================================
 000 |            | No jump instruction
 001 | JGT        | Jump if _out_ > 0
 010 | JEQ        | Jump if _out_ = 0
 011 | JGE        | Jump if _out_ >= 0
 100 | JLT        | Jump if _out_ < 0
 101 | JNE        | Jump if _out_ != 0
 110 | JLE        | Jump if _out_ <= 0
 111 | JMP        | Jump

# Address Instruction

0VVVVVVV VVVVVVVV
^ Denotes an a-instruction

Instruction Decoding
Part             | Description
==========================================================
VVVVVVV VVVVVVVV | 15 bit value to store in the A register

--- 

// Some example assembly

@0
M=1  // Memory[0]=1


mov (a), d
mov d, (a)








# instruction template
[00000000]

# Internal
0xxxxxxx <-    No argument
10xxxxxx <- Load Immediate
11xxxxxx <- Load Address

# Registers
MP  # Memory Pointer
SP  # Stack Pointer
IP  # Instruction Pointer
A   # A Register
B   # B Register
FG  # Flags (ZF, CF, OF, SF, HF, IF)

ldmp $ref       # 
load %reg       # reg={a, b}
store %reg      # reg={a, b}
move %reg, %reg # reg={a, b, mp}
move %reg, !val # reg={a, b, mp}

## Thinking about the assembly language

# From memory
lda some_const # Load a with some_constant
ldr r1         # Load r1 with the data pointed to by a
ldr r2         # Load r1 with the data pointed to by a
str r1         # Store r1 into the memory pointed to by a
str r2         # Store r2 into the memory pointed to by a

# Transfer
mov r2,r1      # move the value in r1 into r2
mov r1,r2      # move the value in r2 into r1
mov a,r1       # move the value in r1 into a
mov a,r2       # move the value in r2 into a
mov r1,a       # move the value in a into r1
mov r2,a       # move the value in a into r2

# Increment/Decrement
inc a          # Increment a
inc r1         # Increment r1
inc r2         # Increment r2
dec a          # decrement a
dec r1         # decrement r1
dec r2         # decrement r2

# Math
add            # r1 + r2
sub            # r1 - r2

# Bitwise
and            # r1 & r2
or             # r1 | r2
xor            # r1 ^ r2
not r1         # not(r1)
not r2         # not(r2)

# Stack
push r1        # push r1 onto the stack
push r2        # push r2 onto the stack
push a         # push a onto the stack
pushf          # push flags onto stack
pusha          # pushs a, r1, r2, flags onto the stack

pop r1        # pop r1 from the stack
pop r2        # pop r2 from the stack
pop a         # pop a from the stack
popf          # pop flags from stack
popa          # pops a, r1, r2, flags from the stack

# Comparison
cmp           # Compaire r1 and r2 and set flags
              # if r1 == r2 = zf=1, sf=0
              # if r1 < r2 = zf=0, sf=0
              # if r1 > r2 = zf=0, sf=1

# Jumps - http://www.unixwiz.net/techtips/x86-jumps.html
jmp           # jmp $immeidate
je            # jmp if %ZF == 1
jne           # jmp if %ZF == 0
jg            # jmp if %ZF == 0 AND %SF == %OF
jge           # jmp if %SF == %OF
jl            # jmp if %SF != %OF
jle           # jmp if %ZF is 1 OR %SF != %OF
jc            # jmp if %CF == 1
jnc           # jmp if %CF == 0
jo            # jmp if %OF == 1
jno           # jmp if %OF == 0
js            # jmp if %SF == 1
jns           # jmp if %SF == 0
ja            # jmp if %CF == 0 AND %ZF == 0
jae           # jmp if %CF == 0
jb            # jmp if %CF == 1
jbe           # jmp if %CF == 1 OR %ZF == 1

# Relisting Jumps and consolidating opcodes to reduce number of bytecodes
jmp           # jmp $immeidate
je            # jmp if %ZF == 1
jne           # jmp if %ZF == 0
jg            # jmp if %ZF == 0 AND %SF == %OF
jge           # jmp if %SF == %OF
jl            # jmp if %SF != %OF
jle           # jmp if %ZF is 1 OR %SF != %OF
jo            # jmp if %OF == 1
jno           # jmp if %OF == 0
js            # jmp if %SF == 1
jns           # jmp if %SF == 0
jnc/jae       # jmp if %CF == 0
ja            # jmp if %CF == 0 AND %ZF == 0
jc/jb         # jmp if %CF == 1
jbe           # jmp if %CF == 1 OR %ZF == 1
